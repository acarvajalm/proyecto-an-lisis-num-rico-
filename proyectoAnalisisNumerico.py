# -*- coding: utf-8 -*-
"""ProyectoAnalisisNumerico.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1IjVg-uln08T5lLvtcVAlHSDmhUJ1MLPb
"""

import sympy as sp
import math

"""1. Método de búsquedas incrementales"""

x = sp.Symbol('x')

def busquedas(fx,x0,paso,ni): 
  if fx.subs(x,x0) == 0:
    return str(x0) + ' es raíz'
  else:
    xn = x0 + paso
    i = 0
    while (ni>i and float(fx.subs(x,x0))*float(fx.subs(x,xn))>0):
      x0 = xn
      xn = xn + paso
      i += 1
  if fx.subs(x,xn) == 0:
    return str(xn) + ' es raíz'
  elif float(fx.subs(x,x0))*float(fx.subs(x,xn))<0:
    return 'entre ' + str((x0,xn)) + ' hay raíz'
  else:
    return 'no se encontró raíz'

busquedas(x-1,0,0.5,10)

"""2. Método de las bisecciones"""

x = sp.Symbol('x')

def bisecciones(fx,xi,xf,n,t):
  if float(fx.subs(x,xi))*float(fx.subs(x,xf)) == 0:
    return str(xi) + 'O' + str(xf) + 'son raíces'
  elif float(fx.subs(x,xi))*float(fx.subs(x,xf)) > 0:
    return 'no hay raíz'
  else:
    xm = (xi + xf)/2
    cont = 0
    error = abs(xi-xm)
    while(error > t and n > cont and float(fx.subs(x,xm))!= 0):
      if float(fx.subs(x,xi))*float(fx.subs(x,xm)) < 0:
        xf = xm 
      else:
        xi = xm 
      xm = (xi+xf)/2
      error = abs(xm-xi)
      cont += 1
    if fx.subs(x,xm) == 0:
      return str(xm)+ ' es raíz'
    elif error < t:
      return str(xm) + ' es raíz con tolerancia ' + str(t)
    else:
      return 'no se encunetra solución'

bisecciones(x,-2,2,50, 0.01)

"""3. Método de punto fijo"""

x = sp.Symbol('x')

def puntoFijo(f,x0,n, t):
  g=-(f-x)
  i = 0
  error = t + 1
  while (i < n and error > t):
    xn = float(g.subs(x,x0))
    error = abs(xn - x0)
    i += 1
    x0 = xn
  if error <= t:
    print(str(xn) + " es raíz con tolerancia " + str(t))
  else:
    print("No converge")

"""4. Método de regla falsa"""

x = sp.Symbol('x')

def reglaFalsa (xi, xf, f, t, n):
  if (f.subs(x,xi) * f.subs(x,xf) == 0):
    if (f.subs(x,xi) == 0):
      print("Hay una raíz de en " + str(xi))
    if (f.subs(x,xf) == 0):
      print("Hay una raíz en " + str(xf))
  elif (f.subs(x,xi) * f.subs(x,xf) > 0):
    print("No se encuentra solución")
  else: 
    xm = xf -((f.subs(x,xf)*(xi-xf))/(f.subs(x,xi)-f.subs(x,xf)))
    xm = float(xm)
    ni = 0
    error = abs(xi-xm)
    while (error>t and ni<n and f.subs(x,xm) != 0):
      if (f.subs(x,xi) * f.subs(x,xm) < 0):
        xf = xm
      else: 
        xi = xm
      xm = xf -((f.subs(x,xf)*(xi-xf))/(f.subs(x,xi)-f.subs(x,xf)))
      xm = float(xm)
      error = abs(xm - xf)
      ni += 1
    if (f.subs(x,xm) == 0):
      print("Se halló una raíz en " + str(xm) )
    elif error < t: 
      print( str(xm) + " Es raíz con una toleracia  " + str(t))
    else:
      print("No se encuentra una solución")

"""5. Método de Newton"""

x = sp.Symbol('x')

def newton(fx,x0,n,t):
  dfx = sp.diff(fx,x)
  cont = 0
  error = t + 1
  while(cont < n and error > t):
    xn = x0 - float(fx.subs(x,x0))/float(dfx.subs(x,x0))
    error = abs(xn-x0)
    cont += 1
    x0 = xn
  if error <= t:
    return str(xn) + ' es raíz con tolerancia: ' + str(t)
  else:
    return 'No converge'

"""6. Método de la secante"""

x = sp.Symbol('x')

def secante(fx,x0,xn,n,t):
  cont = 0
  error = t + 1
  v = 1
  while(cont < n and error > t):
    if float(fx.subs(x,xn))-float(fx.subs(x,x0)) ==  0: 
      print  ('¡DENOMINADOR IGUAL A CERO EN LA ITERACIÓN ' + str(cont) + '! '  + 'por  favor eliga otros x0,xn')
      v = 0
      break
    xn1 = xn-((((xn-x0)/(float(fx.subs(x,xn))-float(fx.subs(x,x0)))))*float(fx.subs(x,xn)))
    x0 = xn
    xn = xn1
    error = abs(xn-x0)
    cont += 1
  if error <= t:
    return str(xn) + ' es raíz con tolerancia: ' + str(t)
  elif v == 1:
    return 'No converge'

"""7. Método de raíces múltiples"""

x = sp.Symbol('x')

def raices(fx,x0,n,t):
  dfx = sp.diff(fx,x)
  fx= fx/dfx
  dfx = sp.diff(fx,x)
  cont = 0
  error = t + 1
  while(cont < n and error > t):
    xn = x0 - float(fx.subs(x,x0))/float(dfx.subs(x,x0))
    error = abs(xn-x0)
    cont += 1
    x0 = xn
  if error <= t:
    return str(xn) + ' es raíz con tolerancia: ' + str(t)
  else:
    return 'No converge'